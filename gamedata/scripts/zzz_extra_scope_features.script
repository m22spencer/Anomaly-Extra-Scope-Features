-- to add magnifications via DLTX (check console after zooming weapon for names)
-- ![scope_or_weapon_name]
-- magnifications = 2, 3.5, 6

local options = { only_zoom_when_rotated = true }


-- patch to change the conversion of scope config information
function scope_zoom_factor_to_magnification(szf)
    if szf then
        return szf < 1 and 1 or 60 / szf
    end
end

local TO_RADIANS = 3.14159 / 180
local TO_DEGREES = 1 / TO_RADIANS
local PI = 3.14159;

-- Find fov that would result in magnification in screen space
function mag_to_fov(cur_fov, magnification)
    return (2 * math.atan( math.tan(cur_fov/2) * (1/magnification) ))
end

function mag_between_fovs(x, y)
    return 1 / (math.tan(y/2) / math.tan(x/2))
end

function fov_to_zoomfactor(fov)
	return fov * TO_DEGREES / 0.75
end

function zoomfactor_to_fov(zf)
	return zf * 0.75 * TO_RADIANS
end

local floatg = "(%d*%.?%d*)"
local p_mag   = "^" .. floatg .. "$"
local p_mag_r = "^" .. floatg .. "-" .. floatg .. "$"
function parse_magnification(str)
    str = str:gsub("%s+", "")
    local l,h = str:match(p_mag_r)
    l = tonumber(l or str:match(p_mag))
    h = tonumber(h)

    return {l = l, h = h or l}
end

function read_magnifications(section, alt)
    local magnifications = ini_sys:r_list(section, alt and "magnifications_alt" or "magnifications")
    if magnifications then
        for k,v in pairs(magnifications) do
            magnifications[k] = parse_magnification(v)
        end
    end
    return magnifications
end

function read_gamma_3dss(section, alt)
    local max = ini_sys:r_float_ex(section, alt and "magnification_alt" or "magnification")
                    or scope_zoom_factor_to_magnification(ini_sys:r_float_ex(section, alt and "scope_zoom_factor_alt" or "scope_zoom_factor"))
    local mz = ini_sys:r_float_ex(section, alt and "3ds_ffp_min_zoom_alt" or "3ds_ffp_min_zoom")
    local min = (mz and scope_zoom_factor_to_magnification(mz))
            or (ini_sys:r_bool_ex(section, alt and "scope_dynamic_zoom_alt" or "scope_dynamic_zoom") and 1)
            or nil
    return {parse_magnification(min and (min .. "-" .. max)
                                    or tostring(max))}
end

function _active_2d_scope()
    local item = db.actor:active_item()
    local weapon = item and item:cast_Weapon()
    if weapon then 
        if not weapon:IsZoomed() then
            return nil
        end
        local zoomtype = weapon:GetZoomType()

        local section = zoomtype == 0 and utils_item.get_attached_scope(item) or item:section()
        local isAlt = zoomtype ~= 0

        function f(section, isAlt)
            local m = read_magnifications(section, isAlt)
            return m and { magnifications = m, origin = "magnifications" }
                     or  { magnifications = read_gamma_3dss(section, isAlt), origin = "gamma_3dss" }
        end

        printf("Read gamma_3ds: " .. section .. " alt? " .. (isAlt and "yes" or "no"))
        local r = f(section, isAlt)
        r.weapon = section
        r.zoomtype = zoomtype

        printf(utils_data.print_table(r.magnifications, "r.magnifications", true))

        item:iterate_installed_upgrades(function(upgrade) 
            local upgrade_section = ini_sys:r_string_ex(upgrade, "section")
            local ur = f(upgrade_section, isAlt)
            printf(utils_data.print_table(ur, "ur", true))
            if #ur.magnifications ~= #r.magnifications then
                printf("Invalid number of entries in upgrade " .. upgrade_section)
                return
            end
            for k,v in pairs(ur.magnifications) do
                local rk = r.magnifications[k]
                local uk = ur.magnifications[k]
                rk.l = rk.l + uk.l
                rk.h = rk.h + uk.h
            end
        end)

        return r;
    end
end

local property_cache = {}

function active_2d_scope()
    local item = db.actor:active_item()
    local key = item and get_item_key(item)

    if key then
        if not property_cache[key] then
            local r = _active_2d_scope()
            if not r then
                return nil
            end
            if not r.magnifications[1].l then
                printf("Error: Missing low mag")
                printf(utils_data.print_table(r, "active_2d_scope", true))
                return nil
            elseif not r.magnifications[1].h then
                printf("Error: Missing high mag")
                printf(utils_data.print_table(r, "active_2d_scope", true))
                return nil
            end
            printf("New item seen: " .. key)
            r.key = key
            r.zoom_cache = 0.0
            property_cache[key] = r
        end
        return property_cache[key]
    end
end

function get_item_key(item) 
    local weapon = item and item:cast_Weapon()
    if not weapon then
        return nil
    end
    local id       = item:id()
    local zoomtype = weapon:GetZoomType()
    local section  = zoomtype == 0
                        and utils_item.get_attached_scope(item)
                        or  item:section()
    local upgrades = ""

    item:iterate_installed_upgrades(function(upgrade_section) upgrades = upgrades .. "+" .. upgrade_section end)
    return id .. ":" .. zoomtype .. ":" .. section .. ":" .. upgrades
end

local last_key = nil
function actor_on_update() 
    
    local item = db.actor:active_item()
    local weapon = item and item:cast_Weapon()

    local info = active_2d_scope()
    if info and item and weapon then 
        if last_key ~= info.key then
            printf("Aim type changed: " .. (last_key or "nil") .. " -> " .. (info and info.key or "nil"))
            last_key = info.key
            print_optic_detail(info) 
        end
        if not info.zoom_cache then 
            info.zoom_cache = 0.0;
        end
        local magnification = info.dynamic_zoom and info.max_magnification and (info.dynamic_zoom and info.zoom_cache or 1) * (info.max_magnification - 1) + 1
        local min_magnification

        if info.magnifications then 
            local mag1 = info.magnifications[1]
            if not tonumber(mag1) then
                

                local frac = info.zoom_cache;
                magnification = (mag1.h - mag1.l) * frac + mag1.l;
                min_magnification = mag1.l
            else
                local levels = size_table(info.magnifications);
                local index = math.floor(1 + info.zoom_cache * (levels - 1));

                magnification = tonumber(info.magnifications[index] or magnification)
            end
        end

        local scope_factor = get_console():get_float("scope_factor");
        local max_pip_magnification = 1.0/scope_factor;

        

        local pip_magnification = math.min( magnification
                                          , max_pip_magnification)

        local remaining_magnification = magnification / pip_magnification
        
        local player_fov = get_console():get_float("fov") * TO_RADIANS
        local target_fov = mag_to_fov(player_fov, magnification)
        

        local fov_factor = mag_to_fov( player_fov
                                     , remaining_magnification)

        

        local zoom_factor  = options.only_zoom_when_rotated
            and weapon:GetInertionAimFactor() > 0.001 and fov_to_zoomfactor(player_fov)
            or fov_to_zoomfactor(fov_factor)
        

        weapon:SetZoomFactor(zoom_factor)


        local get = z_3d_scopes.get
        local section = item:section()

        local x = math.floor(get(section, "3ds_type")) + (player_fov / 3.14159)
        local y = math.floor(min_magnification or magnification)  + (target_fov / 3.14159)
        get_console():execute(
            "shader_param_6 " .. 
            x .. ", " ..
            y .. ", " ..
            get(section, "3ds_reticle_size") .. ", " ..
            get(section, "3ds_shadow_project"))
    end
end

function on_mouse_wheel(scroll_dir, flags) 
    local info = active_2d_scope()
    if info and scroll_dir then
        local mag_levels = info.magnifications and tonumber(info.magnifications[1])
            and (size_table(info.magnifications)-1)
            or get_console():get_float("zoom_step_count")

        local zoom_step = 1 / mag_levels

        local scroll_delta = scroll_dir * 2 - 1;

        local item = db.actor:active_item()
        info.zoom_cache = clamp((info.zoom_cache or 0) + scroll_delta * zoom_step, 0, 1)
        flags.ret_value = false
    end
end

local mwheel_supported_ver	= 20230701
local mwheel_avail 			= MODDED_EXES_VERSION and (MODDED_EXES_VERSION >= mwheel_supported_ver)

function print_optic_detail(info) 
    local mag_string
    if info.magnifications then
        local m_str = ""
        for k,v in pairs(info.magnifications) do

            m_str = m_str .. (v.l == v.h and tonumber(v.l) or (v.l .. "-" .. v.h) or "")
        end
        mag_string = "Magnifications: " .. tostring(info.magnifications and m_str)
    end

    printf( "Weapon: " .. info.weapon 
         .. (info.scope and (" Scope: " .. info.scope) or "")
         .. " " .. mag_string 
         .. " origin: " .. (info.origin or "nil")
        )
end

function on_game_start()
    -- Compatibility patches
    if scopes_as_binocs then
        -- sets the zoom factor, which overrides our fixes
        scopes_as_binocs.actor_on_update = function() end
    end
    if zoomed_out_scope_draw then
        zoomed_out_scope_draw.actor_on_weapon_zoom_in = function() end
        zoomed_out_scope_draw.actor_on_weapon_zoom_out = function() end
    end

	RegisterScriptCallback("actor_on_update", actor_on_update)
    if mwheel_avail then
		RegisterScriptCallback("on_mouse_wheel",on_mouse_wheel)
	end

    RegisterScriptCallback("actor_on_weapon_zoom_out", function()
    end)

    add_scope_radii('wpn_crosshair_bino', 1.0)

    RegisterScriptCallback("actor_on_weapon_zoom_in", function()
        local info = active_2d_scope()
        if info then
            print_optic_detail(info)

            actor_on_update()
        end
    end)
end
