-- patch to change the conversion of scope config information
function scope_zoom_factor_to_magnification(szf)
    return 60 / szf
end

local to_rads = 3.14159 / 180
local to_degs = 1 / to_rads

-- conversions -------------------------------------------------------------------------
-- FIXME: these are not quite correct, need to dig through xray-monolith project
function mag_to_fov(cur_fov, mag)
	return (2 * math.atan( math.tan(cur_fov*to_rads/2) * (1/mag) )) * to_degs
end

-- x and y are in degrees
function mag_between_fovs(x, y)
    x = x * to_rads
    y = y * to_rads

    return 1 / (math.tan(y/2) / math.tan(x/2))
end

-- TODO: reverse the formula in xray-monolith to double check. This seems to work though
function fov_to_zoomfactor(fov)
	return fov / 0.75
end

function zoomfactor_to_fov(zf)
	return zf * 0.75
end
-- end conversions

function active_2d_scope()
    local item = db.actor:active_item()
    local weapon = item and item:cast_Weapon()
    if weapon then 
        if not weapon:IsZoomed() then
            return nil
        end
        local zoomtype = weapon:GetZoomType()

        if zoomtype == 0 then
            local scope = utils_item.get_attached_scope(item)
            if scope then
                local zf = ini_sys:r_float_ex(scope, "scope_zoom_factor")
                if zf and zf > 0 then 
                    return { max_magnification = scope_zoom_factor_to_magnification(zf)
                           , dynamic_zoom      = ini_sys:r_float_ex(scope, "scope_dynamic_zoom") }
                else
                    return nil
                end
            else
                local section = item:section()
                local id = item:id()
                local zf = utils_item.get_param(section, id, "scope_zoom_factor", "float")
                if zf and zf > 0 then 
                    return { max_magnification = scope_zoom_factor_to_magnification(zf)
                           , dynamic_zoom      = utils_item.get_param(section, id, "scope_dynamic_zoom", "bool") }
                else
                    return nil
                end
            end
        else
            -- grenade launcher or alternate sight
            return nil
        end
    end
end

local config_max_pip_magnification = 2.0

local zoom_cache = {}

function actor_on_update() 
    local info = active_2d_scope()

    local item = db.actor:active_item()
    local weapon = item and item:cast_Weapon()
    if info and item and weapon then 
        local magnification = (info.dynamic_zoom and zoom_cache[item:id()] or 1) * (info.max_magnification - 1) + 1

        local pip_magnification = math.min( magnification
                                          , config_max_pip_magnification)

        local remaining_magnification = magnification / pip_magnification


        local fov_factor = mag_to_fov( get_console():get_float("fov")
                                     , remaining_magnification)

        local zoom_factor  = fov_to_zoomfactor(fov_factor)
        local scope_factor = 1/pip_magnification

        -- attempt to correct the zoom over time by modifying the scope_factor
        local fov_mag_error_approx = mag_between_fovs(device().fov, zoomfactor_to_fov(zoom_factor))
        scope_factor = 1/(pip_magnification * fov_mag_error_approx)

        -- To retain correct mouse sensitivity we encode a mag value <1 as 0.99MMMM
        local encoded = (scope_factor > 1)
            and (scope_factor / 1000 + 0.99)
            or  (scope_factor * 0.99)

        exec_console_cmd("scope_factor " .. encoded)
        weapon:SetZoomFactor(zoom_factor)

        if false then 
            printf( " mag: " .. magnification .. "x"
                .. " pip: " .. pip_magnification .. "x"
                .. " zoom: " .. remaining_magnification .. "x"
                .. " zoom_factor: " .. zoom_factor
                .. " scope_factor: " .. scope_factor
                )
        end
    end
end

function on_mouse_wheel(scroll_dir, flags) 
    if scroll_dir and active_2d_scope() then
        local zoom_step = 1 / get_console():get_float("zoom_step_count")

        local scroll_delta = scroll_dir * 2 - 1;

        local item = db.actor:active_item()
        zoom_cache[item:id()] = clamp((zoom_cache[item:id()] or 0) + scroll_delta * zoom_step, 0, 1)
        flags.ret_value = false
    end
end

local mwheel_supported_ver	= 20230701
local mwheel_avail 			= MODDED_EXES_VERSION and (MODDED_EXES_VERSION >= mwheel_supported_ver)

function on_game_start()
    -- Compatibility patches
    if scopes_as_binocs then
        -- sets the zoom factor, which overrides our fixes
        scopes_as_binocs.actor_on_update = function() end
    end
    if zoomed_out_scope_draw then
        zoomed_out_scope_draw.actor_on_weapon_zoom_in = function() end
        zoomed_out_scope_draw.actor_on_weapon_zoom_out = function() end
    end

	RegisterScriptCallback("actor_on_update", actor_on_update)
    if mwheel_avail then
		RegisterScriptCallback("on_mouse_wheel",on_mouse_wheel)
	end
end