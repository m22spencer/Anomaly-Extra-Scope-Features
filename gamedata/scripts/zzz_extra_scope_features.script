--[[ 
to add magnifications via DLTX (check console after zooming weapon for names)

section search priority is attached_scope, then item section
magnifications takes a comma separated list of 
exact zoom   : N
variable zoom: M-N

Anomaly equivalents \/
scope_zoom_factor 15 , dynamic_zoom no  -> magnifications = 4
scope_zoom_factor 7.5, dynamic_zoom yes -> magnifications = 1-8

No anomaly equivalent \/
toggle between exact zooms              -> magnifications = 2, 4, 8
combination of the above                -> magnifications = 2-8, 16
]]--

local options = { -- Delay the zoom in until the optic is (near) centered 
                  -- Gives the eye a distraction and may feel closer to pip
                  only_zoom_when_rotated = true     

                  -- makes dynamic zoom seem more like a dial, but feels detached/laggy
                , use_linear_smoothzoom  = false    
                }

-- patch to change the easing function for dynamic zoom
function calculate_smoothzoom_delta(current, target, delta_seconds)
    if use_linear_smoothzoom then
        local dir    = (target > current) and 1 or -1
        local amount = 4.0 * delta_seconds
        return math.min(math.abs(target - current), amount) * dir
    else
        return (target - current) / math.max(8.0 / (delta_seconds * 77), 1)
    end
end

-- patch to change the conversion of scope config information
function scope_zoom_factor_to_magnification(szf)
    if szf then
        return szf < 1 and 1 or 60 / szf
    end
end

local TO_RADIANS = 3.14159 / 180
local TO_DEGREES = 1 / TO_RADIANS
local PI = 3.14159;

-- Find fov that would result in magnification in screen space
--    if you change this, you must provide matching tc calculations in the shader
function mag_to_fov(cur_fov, magnification)
    return (2 * math.atan( math.tan(cur_fov/2) * (1/magnification) ))
end

function mag_between_fovs(x, y)
    return 1 / (math.tan(y/2) / math.tan(x/2))
end

function fov_to_zoomfactor(fov)
	return fov * TO_DEGREES / 0.75
end

function zoomfactor_to_fov(zf)
	return zf * 0.75 * TO_RADIANS
end

local floatg = "(%d*%.?%d*)"
local p_mag   = "^" .. floatg .. "$"
local p_mag_r = "^" .. floatg .. "-" .. floatg .. "$"
function parse_magnification(str)
    str = str:gsub("%s+", "")
    local l,h = str:match(p_mag_r)
    l = tonumber(l or str:match(p_mag))
    h = tonumber(h)

    return {l = l, h = h or l}
end

function read_magnifications(section, alt)
    local magnifications = ini_sys:r_list(section, alt and "magnifications_alt" or "magnifications")
    if magnifications then
        for k,v in pairs(magnifications) do
            magnifications[k] = parse_magnification(v)
        end
    end
    return magnifications
end

function read_gamma_3dss(section, alt)
    local max = ini_sys:r_float_ex(section, alt and "magnification_alt" or "magnification")
                    or scope_zoom_factor_to_magnification(ini_sys:r_float_ex(section, alt and "scope_zoom_factor_alt" or "scope_zoom_factor"))
    local mz = ini_sys:r_float_ex(section, alt and "3ds_ffp_min_zoom_alt" or "3ds_ffp_min_zoom")
    local min = (mz and scope_zoom_factor_to_magnification(mz))
            or (ini_sys:r_bool_ex(section, alt and "scope_dynamic_zoom_alt" or "scope_dynamic_zoom") and 1)
            or nil
    
    return (not max) 
        and {}
        or  {parse_magnification(min and (min .. "-" .. max)
                                     or tostring(max))}
end

function _active_2d_scope()
    local item = db.actor:active_item()
    local weapon = item and item:cast_Weapon()
    if weapon then 
        if not weapon:IsZoomed() then
            return nil
        end
        local zoomtype = weapon:GetZoomType()

        local section = zoomtype == 0 and utils_item.get_attached_scope(item) or item:section()
        local isAlt = zoomtype ~= 0

        function f(section, isAlt)
            local m = read_magnifications(section, isAlt)
            local r = m and { magnifications = m, origin = "magnifications" }
                        or  { magnifications = read_gamma_3dss(section, isAlt), origin = "gamma_3dss" }
            r.magnifications = #r.magnifications == 0 and {{l = 1, h = 1}} or r.magnifications
            return r
        end

        debug("Read gamma_3ds: " .. section .. " alt? " .. (isAlt and "yes" or "no"))
        local r = f(section, isAlt)
        r.weapon = section
        r.zoomtype = zoomtype

        debug(utils_data.print_table(r.magnifications, "r.magnifications", true))

        item:iterate_installed_upgrades(function(upgrade) 
            local upgrade_section = ini_sys:r_string_ex(upgrade, "section")
            local ur = f(upgrade_section, isAlt)
            debug(utils_data.print_table(ur, "upgrade_magnifiction", true))
            if #ur.magnifications == 0 then
                -- Upgrade does not contain optic information
                return
            end
            if #ur.magnifications ~= #r.magnifications then
                error("Invalid number of entries in upgrade magnification " .. upgrade_section)
                return
            end
            for k,v in pairs(ur.magnifications) do
                local rk = r.magnifications[k]
                local uk = ur.magnifications[k]
                if not uk.l or not uk.h then
                    error("Unable to apply magnification change from upgrade: " .. upgrade_section)
                else
                    rk.l = rk.l + uk.l
                    rk.h = rk.h + uk.h
                end
            end
        end)

        return r;
    end
end

local property_cache = {}

function active_2d_scope()
    local item = db.actor:active_item()
    local weapon = item and item:cast_Weapon()
    local key = item and get_item_key(item)

    if key and (weapon and weapon:IsZoomed()) then
        if not property_cache[key] then
            local r = _active_2d_scope()
            if not r then
                return nil
            end
            debug("New item seen: " .. key)
            r.key = key
            r.zoom_cache = 1
            r.current_mag = r.magnifications[1].l
            r.target_mag  = r.current_mag
            property_cache[key] = r
        end
        return property_cache[key]
    end
end

function get_item_key(item) 
    local weapon = item and item:cast_Weapon()
    if not weapon then
        return nil
    end
    local id       = item:id()
    local zoomtype = weapon:GetZoomType()
    local section  = zoomtype == 0
                        and utils_item.get_attached_scope(item)
                        or  item:section()
    local upgrades = ""

    item:iterate_installed_upgrades(function(upgrade_section) upgrades = upgrades .. "+" .. upgrade_section end)
    return id .. ":" .. zoomtype .. ":" .. section .. ":" .. upgrades
end

function current_magnification(info) 
    local zsc = get_console():get_float("zoom_step_count")
    local zsc_err = ((zsc + 1) / zsc)
    local range = info.magnifications[math.floor(info.zoom_cache)]
    local zoom_frac = math.fmod(info.zoom_cache, 1) * zsc_err
    return (range.h - range.l) * zoom_frac + range.l
end

local last_key = nil
function actor_on_update() 
    
    local item = db.actor:active_item()
    local weapon = item and item:cast_Weapon()

    local info = active_2d_scope()
    if info and item and weapon then 
        if last_key ~= info.key then
            debug("Aim type changed: " .. (last_key or "nil") .. " -> " .. (info and info.key or "nil"))
            last_key = info.key
            print_optic_detail(info) 
        end

        local delta_seconds = device().f_time_delta
        local mag_delta = calculate_smoothzoom_delta(info.current_mag, info.target_mag, delta_seconds)
        local max_delta = math.abs(info.target_mag - info.current_mag)
        info.current_mag = info.current_mag + math.min(mag_delta, max_delta)        

        local magnification = info.current_mag
        local min_magnification = info.magnifications[1].l  -- hack to make shader work until rewrite

        local scope_factor = get_console():get_float("scope_factor");
        local max_pip_magnification = 1.0/scope_factor;

        local pip_magnification = math.min( magnification
                                          , max_pip_magnification)

        local remaining_magnification = magnification / pip_magnification
        
        local player_fov = get_console():get_float("fov") * TO_RADIANS
        local target_fov = mag_to_fov(player_fov, magnification)
        

        local fov_factor = mag_to_fov( player_fov
                                     , remaining_magnification)

        

        local zoom_factor  = options.only_zoom_when_rotated
            and weapon:GetInertionAimFactor() > 0.001 and fov_to_zoomfactor(player_fov)
            or fov_to_zoomfactor(fov_factor)
        

        weapon:SetZoomFactor(zoom_factor)

        local get = z_3d_scopes.get
        local section = item:section()

        local x = math.floor(get(section, "3ds_type")) + (player_fov / 3.14159)
        local y = math.floor(min_magnification)  + (target_fov / 3.14159)
        get_console():execute(
            "shader_param_6 " .. 
            x .. ", " ..
            y .. ", " ..
            get(section, "3ds_reticle_size") .. ", " ..
            get(section, "3ds_shadow_project"))
    end
end

-- If wantClamp is false, the zoom will wrap.  Useful to support a "cycle zoom" keybind
function change_zoom(info, direction, wantClamp)
    if info then
        local step_count = get_console():get_float("zoom_step_count")
        local step_count_1 = step_count + 1
        local step_mapping = (step_count/step_count_1)

        local n = #info.magnifications

        local czc = info.zoom_cache

        function fixed(zc)
            local cur = info.magnifications[math.floor(zc+0.01)]
            return cur.l == cur.h
        end

        function clampOrWrap(v, min, max)
            return wantClamp
                and clamp(v, min, max)
                or (v > max and min)
                or (v < min and max)
                or v
        end

        -- For zoom, the integer component selects the magnification index
        --    and the fractional component maps between the .l and .r values of said index
        if direction > 0 and fixed(info.zoom_cache) then 
            info.zoom_cache = clampOrWrap(info.zoom_cache + 1.0, 1, n + step_mapping)
        else 
            info.zoom_cache = clampOrWrap(info.zoom_cache + (direction / step_count_1), 1, n + step_mapping)
        end
        
        if fixed(info.zoom_cache) then
            info.zoom_cache = math.floor(info.zoom_cache+0.01)
        end

        info.target_mag = current_magnification(info)
        if fixed(info.zoom_cache) or fixed(czc) then
            -- If swapping to or from a fixed magnification, we want the view to instantly change
            info.current_mag = info.target_mag
        end

        debug("Target magnification: %s", info.target_mag)
    end
end

function on_mouse_wheel(scroll_dir, flags) 
    local info = active_2d_scope()
    if info and scroll_dir and (not actor_menu.inventory_opened())then
        local i = get_console():get_bool("mouse_wheel_invert_zoom") and -1 or 1

        change_zoom(info, i*(scroll_dir*2-1), true)

        flags.ret_value = false
    end
end
local mwheel_supported_ver	= 20230701
local mwheel_avail 			= MODDED_EXES_VERSION and (MODDED_EXES_VERSION >= mwheel_supported_ver)

function print_optic_detail(info) 
    local mag_string
    if info.magnifications then
        local m_str = ""
        for k,v in pairs(info.magnifications) do
            local vl = tostring(tonumber(v.l))
            local vh = tostring(tonumber(v.h))

            m_str = m_str .. (k > 1 and ", " or "") .. (vl == vh and tonumber(vl) or (vl .. "-" .. vh) or "")
        end
        mag_string = "Magnifications: " .. tostring(info.magnifications and m_str)
    end

    log( "Weapon: " .. info.weapon 
         .. (info.scope and (" Scope: " .. info.scope) or "")
         .. " " .. mag_string 
         .. " origin: " .. (info.origin or "nil")
        )
end

function disable_conflicting_scripts()
    if scopes_as_binocs then
        -- sets the zoom factor, which overrides our fixes
        scopes_as_binocs.actor_on_update = function() end
    end
    if zoomed_out_scope_draw then
        zoomed_out_scope_draw.actor_on_weapon_zoom_in = function() end
        zoomed_out_scope_draw.actor_on_weapon_zoom_out = function() end
    end

    if z_3d_scopes then
        z_3d_scopes.actor_on_update = function() end
    end

    if zzz_mspizzaZoomCalc then
        zzz_mspizzaZoomCalc.actor_on_weapon_zoom_in = function() end
    end
end

function on_game_start()
    disable_conflicting_scripts()    

	RegisterScriptCallback("actor_on_update", actor_on_update)
    if mwheel_avail then
		RegisterScriptCallback("on_mouse_wheel",on_mouse_wheel)
	end

    RegisterScriptCallback("actor_on_weapon_zoom_out", function()
    end)

    add_scope_radii('wpn_crosshair_bino', 1.0)

    RegisterScriptCallback("actor_on_weapon_zoom_in", function()
        local info = active_2d_scope()
        if info then
            print_optic_detail(info)

            actor_on_update()
        end
    end)
end

function debug(...)
    if DEV_DEBUG then
        printf(...)
    end
end

function log(...)
    printf(...)
end

function error(fmt, ...)
    printf("ERROR: " .. fmt, ...)
end