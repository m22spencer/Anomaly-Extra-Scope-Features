-- to add magnifications via DLTX (check console after zooming weapon for names)
-- ![scope_or_weapon_name]
-- magnifications = 2, 3.5, 6

local options = { only_zoom_when_rotated = true }


-- patch to change the conversion of scope config information
function scope_zoom_factor_to_magnification(szf)
    if szf then
        return szf < 1 and 1 or 60 / szf
    end
end

local TO_RADIANS = 3.14159 / 180
local TO_DEGREES = 1 / TO_RADIANS
local PI = 3.14159;

-- Find fov that would result in magnification in screen space
function mag_to_fov(cur_fov, magnification)
    return (2 * math.atan( math.tan(cur_fov/2) * (1/magnification) ))
end

function mag_between_fovs(x, y)
    return 1 / (math.tan(y/2) / math.tan(x/2))
end

function fov_to_zoomfactor(fov)
	return fov * TO_DEGREES / 0.75
end

function zoomfactor_to_fov(zf)
	return zf * 0.75 * TO_RADIANS
end

local floatg = "(%d*%.?%d*)"
local p_mag   = "^" .. floatg .. "$"
local p_mag_r = "^" .. floatg .. "-" .. floatg .. "$"
function parse_magnification(str)
    str = str:gsub("%s+", "")
    local l,h = str:match(p_mag_r)
    l = tonumber(l or str:match(p_mag))
    h = tonumber(h)

    return {l = l, h = h or l}
end

function read_magnifications(section, alt)
    local magnifications = ini_sys:r_list(section, alt and "magnifications_alt" or "magnifications")
    if magnifications then
        for k,v in pairs(magnifications) do
            magnifications[k] = parse_magnification(v)
        end
    end
    return magnifications
end

function read_gamma_3dss(section, alt)
    local max = ini_sys:r_float_ex(section, alt and "magnification_alt" or "magnification")
                    or scope_zoom_factor_to_magnification(ini_sys:r_float_ex(section, alt and "scope_zoom_factor_alt" or "scope_zoom_factor"))
    local mz = ini_sys:r_float_ex(section, alt and "3ds_ffp_min_zoom_alt" or "3ds_ffp_min_zoom")
    local min = (mz and scope_zoom_factor_to_magnification(mz))
            or (ini_sys:r_bool_ex(section, alt and "scope_dynamic_zoom_alt" or "scope_dynamic_zoom") and 1)
            or nil
    
    return (not max) 
        and {}
        or  {parse_magnification(min and (min .. "-" .. max)
                                     or tostring(max))}
end

function _active_2d_scope()
    local item = db.actor:active_item()
    local weapon = item and item:cast_Weapon()
    if weapon then 
        if not weapon:IsZoomed() then
            return nil
        end
        local zoomtype = weapon:GetZoomType()

        local section = zoomtype == 0 and utils_item.get_attached_scope(item) or item:section()
        local isAlt = zoomtype ~= 0

        function f(section, isAlt)
            local m = read_magnifications(section, isAlt)
            local r = m and { magnifications = m, origin = "magnifications" }
                        or  { magnifications = read_gamma_3dss(section, isAlt), origin = "gamma_3dss" }
            r.magnifications = #r.magnifications == 0 and {{l = 1, h = 1}} or r.magnifications
            return r
        end

        printf("Read gamma_3ds: " .. section .. " alt? " .. (isAlt and "yes" or "no"))
        local r = f(section, isAlt)
        r.weapon = section
        r.zoomtype = zoomtype

        printf(utils_data.print_table(r.magnifications, "r.magnifications", true))

        item:iterate_installed_upgrades(function(upgrade) 
            local upgrade_section = ini_sys:r_string_ex(upgrade, "section")
            local ur = f(upgrade_section, isAlt)
            printf(utils_data.print_table(ur, "ur", true))
            if #ur.magnifications == 0 then
                -- Upgrade does not contain optic information
                return
            end
            if #ur.magnifications ~= #r.magnifications then
                printf("Invalid number of entries in upgrade " .. upgrade_section)
                return
            end
            for k,v in pairs(ur.magnifications) do
                local rk = r.magnifications[k]
                local uk = ur.magnifications[k]
                if not uk.l or not uk.h then
                    printf("Unable to apply magnification change from upgrade: " .. upgrade_section)
                else
                    rk.l = rk.l + uk.l
                    rk.h = rk.h + uk.h
                end
            end
        end)

        return r;
    end
end

local property_cache = {}

function active_2d_scope()
    local item = db.actor:active_item()
    local key = item and get_item_key(item)

    if key then
        if not property_cache[key] then
            local r = _active_2d_scope()
            if not r then
                return nil
            end
            printf("New item seen: " .. key)
            r.key = key
            r.zoom_cache = 1
            property_cache[key] = r
        end
        return property_cache[key]
    end
end

function get_item_key(item) 
    local weapon = item and item:cast_Weapon()
    if not weapon then
        return nil
    end
    local id       = item:id()
    local zoomtype = weapon:GetZoomType()
    local section  = zoomtype == 0
                        and utils_item.get_attached_scope(item)
                        or  item:section()
    local upgrades = ""

    item:iterate_installed_upgrades(function(upgrade_section) upgrades = upgrades .. "+" .. upgrade_section end)
    return id .. ":" .. zoomtype .. ":" .. section .. ":" .. upgrades
end

function current_magnification(info) 
    local zsc = get_console():get_float("zoom_step_count")
    local zsc_err = ((zsc + 1) / zsc)
    local range = info.magnifications[math.floor(info.zoom_cache)]
    local zoom_frac = math.fmod(info.zoom_cache, 1) * zsc_err
    local magnification = (range.h - range.l) * zoom_frac + range.l
    return magnification
end

local last_key = nil
function actor_on_update() 
    
    local item = db.actor:active_item()
    local weapon = item and item:cast_Weapon()

    local info = active_2d_scope()
    if info and item and weapon then 
        if last_key ~= info.key then
            printf("Aim type changed: " .. (last_key or "nil") .. " -> " .. (info and info.key or "nil"))
            last_key = info.key
            print_optic_detail(info) 
        end

        info.current_mag = info.current_mag + (info.target_mag - info.current_mag) / 8.0

        local magnification = info.current_mag
        local min_magnification = info.magnifications[1].l

        local scope_factor = get_console():get_float("scope_factor");
        local max_pip_magnification = 1.0/scope_factor;

        

        local pip_magnification = math.min( magnification
                                          , max_pip_magnification)

        local remaining_magnification = magnification / pip_magnification
        
        local player_fov = get_console():get_float("fov") * TO_RADIANS
        local target_fov = mag_to_fov(player_fov, magnification)
        

        local fov_factor = mag_to_fov( player_fov
                                     , remaining_magnification)

        

        local zoom_factor  = options.only_zoom_when_rotated
            and weapon:GetInertionAimFactor() > 0.001 and fov_to_zoomfactor(player_fov)
            or fov_to_zoomfactor(fov_factor)
        

        weapon:SetZoomFactor(zoom_factor)


        local get = z_3d_scopes.get
        local section = item:section()

        local x = math.floor(get(section, "3ds_type")) + (player_fov / 3.14159)
        local y = math.floor(min_magnification or magnification)  + (target_fov / 3.14159)
        get_console():execute(
            "shader_param_6 " .. 
            x .. ", " ..
            y .. ", " ..
            get(section, "3ds_reticle_size") .. ", " ..
            get(section, "3ds_shadow_project"))
    end
end

function on_mouse_wheel(scroll_dir, flags) 
    local info = active_2d_scope()
    if info and scroll_dir and (not actor_menu.inventory_opened()) then
        local step_count = get_console():get_float("zoom_step_count")
        local step_count_1 = step_count + 1

        local scroll_delta = scroll_dir * 2 - 1

        local n = #info.magnifications

        local czc = info.zoom_cache

        function fixed(zc)
            local cur = info.magnifications[math.floor(zc+0.01)]
            return cur.l == cur.h
        end

        if scroll_delta > 0 and fixed(info.zoom_cache) then 
            info.zoom_cache = clamp(info.zoom_cache + 1.0, 1, n + (step_count/(step_count+1)))
        else 
            info.zoom_cache = clamp(info.zoom_cache + (scroll_delta / step_count_1), 1, n + (step_count/(step_count+1)))
        end
        
        if fixed(info.zoom_cache) then
            info.zoom_cache = math.floor(info.zoom_cache+0.01)
        end

        printf("Zoom changed: " .. czc .. " -> " .. info.zoom_cache)
        printf("Current mag: " .. current_magnification(info)) 

        info.target_mag = current_magnification(info)
        if fixed(info.zoom_cache) or fixed(czc) then
            info.current_mag = current_magnification(info)
        end

        flags.ret_value = false
    end
end

local mwheel_supported_ver	= 20230701
local mwheel_avail 			= MODDED_EXES_VERSION and (MODDED_EXES_VERSION >= mwheel_supported_ver)

function print_optic_detail(info) 
    local mag_string
    if info.magnifications then
        local m_str = ""
        for k,v in pairs(info.magnifications) do
            local vl = tostring(tonumber(v.l))
            local vh = tostring(tonumber(v.h))

            m_str = m_str .. (vl == vh and tonumber(vl) or (vl .. "-" .. vh) or "")
        end
        mag_string = "Magnifications: " .. tostring(info.magnifications and m_str)
    end

    printf( "Weapon: " .. info.weapon 
         .. (info.scope and (" Scope: " .. info.scope) or "")
         .. " " .. mag_string 
         .. " origin: " .. (info.origin or "nil")
        )
end

function on_game_start()
    -- Compatibility patches
    if scopes_as_binocs then
        -- sets the zoom factor, which overrides our fixes
        scopes_as_binocs.actor_on_update = function() end
    end
    if zoomed_out_scope_draw then
        zoomed_out_scope_draw.actor_on_weapon_zoom_in = function() end
        zoomed_out_scope_draw.actor_on_weapon_zoom_out = function() end
    end

    if z_3d_scopes then
        z_3d_scopes.actor_on_update = function() end
    end

    if zzz_mspizzaZoomCalc then
        zzz_mspizzaZoomCalc.actor_on_weapon_zoom_in = function() end
    end

	RegisterScriptCallback("actor_on_update", actor_on_update)
    if mwheel_avail then
		RegisterScriptCallback("on_mouse_wheel",on_mouse_wheel)
	end

    RegisterScriptCallback("actor_on_weapon_zoom_out", function()
    end)

    add_scope_radii('wpn_crosshair_bino', 1.0)

    RegisterScriptCallback("actor_on_weapon_zoom_in", function()
        local info = active_2d_scope()
        if info then
            print_optic_detail(info)

            info.current_mag = current_magnification(info)
            info.target_mag  = info.current_mag

            actor_on_update()
        end
    end)
end
